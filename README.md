## 介绍
短链接是指将一个原始的长URL通过特定的算法或服务转化为一个更短、易于记忆的URL。短链接通常只包含几个字符，而原始的长URL可能会非常长。

短链接的原理比较简单，通过一个原始链接生成一个相对短的链接，然后通过访问短链接跳转到原始链接。

如果更细节一些的话，就是：

1. **生成唯一标识符**：当用户输入或提交一个长URL时，短链接服务会生成一个唯一的标识符或者短码。
2. **将标识符与长URL关联**：短链接服务将这个唯一标识符与用户提供的长URL关联起来，并将其保存在数据库或者其他持久化存储中。
3. **创建短链接**：将生成的唯一标识符加上短链接服务的域名（例如：http://v.douyin/）作为前缀，构成一个短链接。
4. **重定向**：当用户访问该短链接时，短链接服务接收到请求后会根据唯一标识符查找关联的长URL，然后将用户重定向到这个长URL。
5. **跟踪统计**：一些短链接服务还会提供访问统计和分析功能，记录访问量、来源、地理位置等信息。

主要作用包括但不限于以下几个方面：

- 提升用户体验：用户更容易记忆和分享短链接，增强了用户的体验
- 节省空间：短链接相对于长URL更短，可以节省字符空间，特别是在一些限制字符数的场合，如微博、短信等。
- 美化：短链接通常更美观、简洁，不会包含一大串字符
- 统计和分析：可以追踪短链接的访问情况，了解用户的行为和喜好。

**项目的技术架构**

在系统设计中，采用JDK17+SpringBoot3&SpringCloud微服务架构，构建高并发、大数据量下仍然能提供高效可靠的短链接生成服务。








## 分片键考虑

功能原型设计的时候是点开网站，左侧有一栏分组，然后点卡分组就能看到短链接

所以是相当于查询的时候会带一个分组的标识

如果按照短链接字段进行分表，相当于这个分页查询接口如果没有分片键分组标识 Gid 字段的话，就会扫描全部分片表，出现读扩散问题。

所以又做了一个路由表，用来查短链接对应的分组。因为短链接跳转的时候是拿短链接来找分组标识。

为什么不用分组标识来找短链接...因为一个分组对应很多个短链接



## 数据一致性
缓存和数据库的一致性

先更新mysql，再删Redis，等下一个请求更新后的数据时，再写到缓存中

考虑过缓存双删，但是不知道两次删除要间隔多久

## 缓存预热
一创建短链接就放进缓存中

**默认一个月**的过期时间

## 缓存击穿
1. 热点数据预加载
2. 热点数据永不过期
3. 分布式锁。

我自己是用了分布式锁，搞了双重判定锁。在获取锁后，再看一下缓存中有没有记录。

## 缓存穿透

1. 分布式锁
2. 布隆过滤器
3. 缓存空值

分布式锁串行化，慢；
布隆过滤器有误判；
缓存空值：短时间存在大量恶意请求，缓存系统会占用大量内存。


组合起来：
如果缓存不存在，找布隆过滤器；布隆过滤器存在，找是否是缓存空值；如果不存在空值，用锁去访问数据库；最后如果没在数据库找到，就存一个空值到缓存中。
## 缓存雪崩
1. 均匀设置过期时间，比如给定一个固定值，再加一个随机数
2. 互斥锁
3. 永不过期，并配合上服务器自己定期刷新替换。

## HTTP 重定向
为了监控数据，用的302，临时重定向。


## 消息队列在短链接的应用
短链接高并发跳转的时候，会去增加监控信息。

为了缓和上游（短链接跳转）和下游（监控信息写入）的流量，用消息队列来进行流量削峰。

用的消费者拉取模式。

用的rocketmq

采用 SpringCloud 架构的短链接项目中，RocketMQ 与 Spring Cloud Alibaba 集成紧密，能更好地满足微服务架构下的消息通信需求，方便运维和监控。

短链接项目中可能需要对监控数据、计费数据等进行延时处理，RocketMQ 的延时消息功能可以满足这种需求。

在需要保证消息处理与数据库操作一致性（例如监控操作）的场景下，RocketMQ 的事务消息能够有效保证业务一致性。
